Internet Computer NNS Proposal Types and Governance Parameters
Proposal Types

InstallCode
InstallCode proposals install, reinstall, or upgrade the code of a canister controlled by the Network Nervous System (NNS). This is how the Internet Computer’s core system canisters (like governance, ledger, etc.) are updated. A conservative ICP holder generally accepts these proposals when they come from trusted code releases, as they are essential for network maintenance. However, they remain cautious—scrutinizing the provenance and hash of the new Wasm—because a malicious or rushed upgrade could concentrate undue power or introduce vulnerabilities. The baseline policy is to approve only well-vetted upgrades (deviating to reject if any doubt exists about the code’s integrity or if the proposal comes from an untrusted source).


UpdateCanisterSettings
UpdateCanisterSettings proposals modify configurations (like controller, memory allocation, freezing threshold) of NNS-controlled canisters. They do not change code, but adjust how canisters behave. From a governance standpoint, these proposals are usually technical and accepted if they follow protocol needs (e.g., adjusting controllers after an upgrade). A wary investor checks that such changes don’t hand control to a single entity without reason, which could centralize power. The default is to approve routine setting changes, but one might reject if a proposal seems to grant excessive privileges or if the new settings could be abused to dilute governance (e.g., by disabling certain checks or allowing unauthorized access).


StopOrStartCanister
StopOrStartCanister proposals halt or resume execution of an NNS-controlled canister. Stopping a canister can “freeze” a malicious or faulty canister, while starting would resume its operations. A cautious voter views these as emergency or maintenance actions. They will support (accept) stopping a canister that is proven harmful (e.g., a buggy canister consuming resources or a compromised one) to protect the network and decentralization – freezing malicious actors protects overall integrity. However, they will insist such measures not be used arbitrarily or to censor innocuous canisters, which could set a centralizing precedent. Starting a previously stopped canister is usually benign (restoring normal function) and is accepted when the issue is resolved. The default is to accept, with a deviation to reject if the context for stopping seems politically motivated or unclear.


HardResetNnsRootToVersion
HardResetNnsRootToVersion is a special “break glass” proposal type that uninstalls and reinstalls the NNS root canister to a specific Wasm version. It’s used only when the normal upgrade path is blocked (for example, if the root canister itself got into a state that prevents upgrades). This extreme measure is akin to rebooting the “brain” of the NNS and is rarely invoked. A conservative investor would approach these with extreme caution: baseline stance might be reject unless absolutely necessary. While it doesn’t directly cause token dilution or affect voting power, an improper use could centralize control (if exploited to install unauthorized code). Thus, they’d only justify deviation to accept if NNS governance is effectively bricked without this reset and the new root code is verifiably correct.


AddSnsWasm
AddSnsWasm proposals add a new SNS canister WASM to the SNS-Wasm canister (SNS-W), making it available for SNS instances to upgrade to. In practice, this is how new versions of SNS (Service Nervous System) canister code (governance, ledger, etc., for SNS DAO projects) are introduced. These proposals have narrow scope – they don’t execute code immediately but allow SNS DAOs to adopt updates. A careful ICP holder generally accepts them if they come from DFINITY or trusted developers and improve the SNS infrastructure, since they foster decentralization by empowering many independent SNS DAOs to upgrade securely. They will verify that the code is audited and not sneaking in backdoors. Since this doesn’t dilute ICP or concentrate NNS power (it serves SNS governance, not NNS governance), the main risk is technical (bad code affecting SNS users). Baseline is accept; only if the WASM’s legitimacy is in question would they consider rejecting.


InsertSnsWasmUpgradePathEntries
InsertSnsWasmUpgradePathEntries proposals inject custom upgrade path entries in SNS-W for one or all SNSs. This allows defining a sequence of allowed upgrades (perhaps skipping versions or applying special migrations). It’s a niche governance tool to ensure SNS canisters can only upgrade along approved paths. A conservative voter sees this as ensuring orderly SNS upgrades, which is generally positive for decentralization (it prevents arbitrary or rogue upgrades in SNS DAOs). They would accept if it’s clearly for the benefit of SNS communities and recommended by the SNS maintainers or DFINITY. There’s little impact on ICP inflation or NNS power balance here. Only if a proposal seems to restrict SNS freedom (for instance, locking SNS DAOs into a certain path unnecessarily) might they hesitate or reject, since over-control could be a subtle centralization of software governance.


BitcoinSetConfig
BitcoinSetConfig proposals adjust the configuration of the Bitcoin integration canister on the IC. This can include settings like fees for Bitcoin transactions, whether the IC should sync new BTC blocks, API availability, etc. Essentially, it fine-tunes how the IC interacts with the Bitcoin network. From an ICP governance perspective, this is technical and doesn’t affect ICP token distribution or voting power. A cautious investor’s baseline is to accept such proposals if they align with security and efficiency – for example, increasing fees to prevent spam or pausing syncing if there’s an issue. They would be concerned if a change could disrupt canister functionality (hurting dapps) or if it was set too permissively (which might introduce security risks). While not directly about centralization, misconfiguration could harm the IC’s reliability. Thus, they watch that proposals come with community consensus or expert input. Deviating to reject would happen if a config change seems rushed or dangerous (like drastically lowering fees, which could invite abuse).

ReviseElectedGuestosVersions
ReviseElectedGuestosVersions proposals elect a new GuestOS version (or remove old ones) in the NNS registry. The GuestOS contains core IC protocol code (the replica software) that nodes run. Adopting such a proposal means the NNS DAO adds a new release (identified by an image hash and download URL) to the list of approved versions that subnets can upgrade to. This is essentially the modern method of “blessing” a replica version. A conservative neuron holder treats these like critical upgrades: they generally accept if the version is thoroughly tested (often these come from DFINITY with release notes) because not upgrading the protocol could leave the network stagnating or vulnerable. The risk of centralization here lies in who controls releases – if one entity pushes code without review, that concentrates influence. Thus, our voter would likely follow known independent reviewers (e.g., CodeGov, ICP Maximalist known neurons) and only accept once due diligence is confirmed. The default is to approve needed upgrades; a deviation to reject is justified if, say, the release has controversial changes (like altering tokenomics or governance rules in code) or insufficient transparency.


ReviseElectedHostosVersions
ReviseElectedHostosVersions proposals manage the list of approved HostOS versions in the registry. The HostOS is the low-level node machine OS (hypervisor) beneath the GuestOS. This proposal can elect new HostOS versions or retire (un-elect) existing ones, ensuring nodes run only vetted operating system updates. It’s typically about security patches or performance improvements to node firmware. From a decentralization viewpoint, these are routine – a single HostOS version running everywhere is fine as long as it’s secure, and updating it doesn’t affect governance power. A cautious investor will usually accept such proposals, trusting the node provider community and core developers to propose needed OS updates. They’d be wary only if a HostOS update were suspected of including something nefarious like surveillance or control mechanisms, which would concentrate power over nodes. Barring such extremes, rejecting is unlikely; the baseline is to approve to keep the infrastructure secure and up-to-date


DeployHostosToSomeNodes
DeployHostosToSomeNodes proposals instruct specific node machines to install a particular HostOS version. This is the second step after electing a version: it actually rolls out the update to certain nodes (perhaps as a staged deployment). For example, the NNS might target a subset of nodes for a new HostOS to test stability. An ICP investor sees this as an operational decision. They typically accept if the HostOS was already elected and the rollout plan is reasonable (not too many nodes at once, minimizing risk). It doesn’t impact token supply or voting power distribution. However, they value decentralization in deployment too – ensuring no single party’s nodes are exclusively updated (or left out) in a way that might advantage one operator. The baseline is to trust the proposed rollout; they’d flag a deviation (maybe reject or delay) if the deployment seemed to target nodes in a way that could be unfair or if there are reports of issues on those nodes.


DeployGuestosToAllSubnetNodes
DeployGuestosToAllSubnetNodes proposals trigger a full subnet upgrade to a new GuestOS (replica software) version. This means every node in a specified subnet will reboot into the new version (one that was previously elected as safe). Such proposals effectively upgrade an entire subnet’s protocol. From a governance perspective, this is critical but expected after a version election. A cautious voter will accept it if the version has been elected and tested. They primarily ensure the process was followed (only elected versions can be deployed) and that the subnet upgrade is needed (usually to apply a new release or patch network-wide). There is no direct effect on ICP distribution or voting centralization here, but there is systemic risk: a bad upgrade could crash a whole subnet. Therefore, investors want to see evidence (like testnet results) that the version is stable. If, say, a serious bug is discovered post-election, they might deviate and reject/postpone the deployment to avoid chaos.

DeployGuestosToSomeApiBoundaryNodes
DeployGuestosToSomeApiBoundaryNodes proposals update the GuestOS on a set of API boundary nodes. API boundary nodes are special nodes that handle external requests to the IC (not running canisters but serving as interface points). This proposal type is about upgrading those gateway nodes’ replica version. It’s a narrower scope than subnets. A careful ICP governance participant will typically approve it as a routine maintenance step, ensuring the boundary nodes are on par with the rest of the network’s version for compatibility and security. Since boundary nodes don’t carry user canister state, the risk is lower. There’s no centralization danger or token dilution here. Only if an upgrade was known to cause connectivity issues or if the targeted boundary nodes were all operated by one entity (raising concerns of bias) would they consider a reject – and that’s unlikely if the proposal is sound.

DeployGuestosToAllUnassignedNodes
DeployGuestosToAllUnassignedNodes proposals update the GuestOS on all nodes that are not currently assigned to any subnet. Unassigned nodes are idle capacity waiting to join subnets. Keeping them updated is important so they’re ready to be added to subnets. This is typically non-controversial. A governance-conscious investor accepts because it improves decentralization – it ensures new nodes (often operated by various independent node providers) have the latest software and can join the network seamlessly. It has no effect on ICP supply or voting, and it treats all unassigned nodes equally, avoiding favoritism. The only concern would be if the update had known issues that could render nodes unusable (which would actually reduce available decentralization by knocking out nodes). In such a scenario, voters might delay or reject until fixed; otherwise, it’s approved by default.


Motion
Motion proposals are advisory polls with no direct on-chain action. They serve to gauge community sentiment or set high-level strategy for the ecosystem. Because they have reward weight 20 (meaning voters are heavily rewarded for participation), they are influential even though they don’t execute code. A conservative ICP investor values motions for signaling, but is wary: since anyone can propose a motion, there’s risk of central entities swaying opinion or using motions to push agendas that might later translate into binding proposals. The baseline policy might be neutral or slightly cautious: they will accept motions that align with decentralization and prudent economic management, and reject those that seem to endorse actions harmful to these principles. For example, a motion suggesting to greatly increase node rewards (diluting ICP) or to centralize control in some way would be rejected as a statement. Motions cost only reputation if ignored, but a pattern of passed motions can influence future decisions, so our voter flags any centralizing or dilutive ideas early by voting no.

UninstallCode
UninstallCode proposals remove the code from a canister (essentially leaving it empty). This is a drastic measure used likely to remove malicious or compromised canister code from NNS-controlled canisters or to quickly halt a canister by wiping it. It’s like “burning down” a system canister’s code (the state may remain but inert). An ICP holder sees this as a last-resort security action. They would only accept if a canister’s code is proven dangerous (e.g., governance decides to uninstall a faulty canister to protect the network). It doesn’t directly cause token dilution or shift governance power, but it is centralizing in effect because it’s the NNS exerting forceful control over a canister (which is appropriate for NNS-owned ones). The default stance is reject because normally we prefer orderly upgrades over uninstallation; a justified deviation to accept arises if leaving the code running poses greater harm to decentralization or security (for instance, a governance canister with a bug might be uninstalled to be replaced with a correct version).


SetDefaultFollowees
SetDefaultFollowees proposals set the default followee neurons that new neurons will automatically follow for each topic. Essentially, this configures whom new participants delegate their votes to if they don’t choose manually. From a centralization standpoint, this is crucial: if defaults all point to a single neuron or a small committee, those entities gain outsized voting power. A conservative investor’s baseline is skepticism – they favor decentralization, so any default following should be broad and balanced. Historically, the Foundation’s neuron was a default followee, which concentrated influence. Our voter would accept a SetDefaultFollowees proposal only if it sets diverse, community-chosen neurons as defaults (thus diluting any one entity’s control) or if it updates an outdated default to something more neutral. If a proposal tries to set a default that seems biased or too concentrated (e.g., all topics default to one known neuron), they will reject it, flagging that as a deviation from the ideal of encouraging new users to make an informed choice or at least follow a variety of leaders. In fact, this proposal type was recently retired from public use as part of improving decentralization, which aligns with the cautious stance that such critical settings shouldn’t be changed lightly.


RegisterKnownNeuron
RegisterKnownNeuron proposals officially register a neuron’s name and description as a “Known Neuron” in the system. Known Neurons (also called named neurons) become visible in the NNS frontend, allowing users to follow them easily. This doesn’t change any protocol parameter; it’s more of a branding/UX improvement. A conservative governance participant supports this concept because it can decentralize influence – it introduces more publicly recognized voices beyond the DFINITY Foundation. They will accept such a proposal if the neuron in question has demonstrated trustworthiness and contributes a unique viewpoint to governance. There’s no dilution risk (no ICP involved) and it arguably combats centralization by giving smaller independent neurons a chance to attract followers. However, they’ll still check that the neuron’s description isn’t misleading or that it’s not a sock-puppet of an already powerful entity. Baseline: accept credible new known neurons; deviate to reject if a neuron’s registration appears to misrepresent itself or if it somehow threatens to confuse/manipulate follower distribution (a rare scenario).


CreateServiceNervousSystem
CreateServiceNervousSystem (SNS) proposals set up a new decentralized autonomous organization (SNS) on the IC. Adopting one will install a suite of canisters (governance, ledger, root, etc.) for a new SNS and define its initial parameters, token distribution, and possibly a sale (decentralization swap) with the Neurons’ Fund contribution. Essentially, this is how new tokenized communities (often dapps launching their governance tokens) bootstrap via the NNS. From an ICP holder’s perspective, this is encouraging decentralization of applications – generally positive. They would usually accept if the proposal clearly meets the criteria (e.g., community backing, technical audits, fair initial tokenomics) because a successful SNS means more usage of the IC (which indirectly benefits ICP). They are cautious that the Neurons’ Fund (community fund) participation is handled fairly so existing ICP stakers aren’t diluted unfairly and that launching this SNS doesn’t concentrate power (we want broad distribution of the new SNS’s tokens). There is minimal direct impact on ICP inflation, except the Neurons’ Fund part which uses neuron maturity, not freshly minted ICP. The baseline is to favor these when due diligence has been done (which often includes a prior forum discussion). A deviation to reject would occur if the SNS proposal seems premature or has red flags (e.g., unclear team, token distribution heavily favoring a single entity – which would go against decentralization ethos).


UpdateNodeRewardsTable
UpdateNodeRewardsTable proposals change the schedule or amounts by which node providers are rewarded in different categories (geography, hardware, etc.). The Node Rewards Table essentially sets how much ICP per month each node can earn, depending on factors like location and type (to incentivize a distributed network). Adjusting this table can increase or decrease rewards for certain node operators. A conservative investor knows that raising node rewards means higher ICP inflation (dilution) to pay them, but also that too-low rewards might drive providers away (which could centralize or weaken the network). Their default stance is caution: carefully examine why a change is proposed. If it’s to encourage decentralization (say, increasing rewards for underrepresented regions to get more diverse node distribution) and is balanced by decreases elsewhere or overall manageable inflation, they may accept it. But if it looks like an across-the-board increase with no clear benefit except paying out more (thus diluting token supply), they lean reject. Similarly, if it drastically cuts rewards, they worry providers might drop out, harming network health – which is also bad for decentralization. So they seek a Goldilocks outcome: sufficient reward for a robust, distributed node network, without excessive inflation. Any deviation from baseline (like accepting a slight inflation increase) is only justified if it clearly strengthens the network’s decentralization or security in return.


NetworkEconomics (Economic Parameter Changes)
NetworkEconomics proposals modify one or several key economic and governance parameters of the NNS. These include things like the cost to submit a proposal, minimum neuron staking requirements, and more (detailed in the next section). A single proposal can adjust multiple parameters at once, but each parameter has a default (unchanged) if set to zero, so proposals typically set only the fields they want to change. This type is perhaps the most directly relevant to an ICP investor’s concerns: they can influence spam prevention (proposal reject cost, neuron fees), accessibility (min neuron stake), governance incentives, and ICP usage (transaction fees). The cautious baseline is status quo bias – do not change these unless there is a compelling reason – because each has implications for either centralization or dilution:
Lowering costs or stakes could invite spam or too many trivial neurons (potentially making governance chaotic or letting exchanges split funds into many small neurons to amplify voting power).
Raising costs or stakes could exclude smaller holders (centralizing governance to whales).
Adjusting rewards or spawn delays could indirectly affect ICP inflation.
Thus, an investor will scrutinize who sponsors the change and why. Generally, they accept NetworkEconomics proposals that clearly improve decentralization (e.g., reducing the minimum stake slightly to allow more people to participate, or increasing reject fees to deter spam from a single entity flooding proposals). They reject those that seem to entrench power or boost inflation beyond the original design (like significantly upping node rewards cap or drastically changing fees in a way that benefits a narrow group). Each specific parameter change has its own reasoning threshold, which we detail below. Any deviation from the default “no change” stance is signaled explicitly by the proposer’s justification, and our voter will flag if an exceptional approval (or disapproval) is warranted case-by-case.


CreateSubnet
CreateSubnet proposals form a new subnet blockchain out of a set of independent node machines. This increases network capacity and decentralization by adding another parallel blockchain to the IC. The NNS chooses a batch of nodes (ensuring they are from diverse data centers and operators to maintain independence) and runs the distributed key generation to initialize the subnet’s identity. For a decentralization-focused ICP holder, CreateSubnet is usually very positive – it means growth of the network. They will vote to adopt (accept) as long as the nodes come from a healthy mix of providers (preventing any single party from controlling the new subnet). It does not dilute ICP directly; in fact, it’s a sign of scaling. The only caution is if, hypothetically, a subnet were created entirely with nodes from one new entity with little track record – that could concentrate too much power in that subnet. In that case, a voter might demand adjustments (like a more diverse node set) or else lean to reject until that is fixed. But generally, CreateSubnet is aligned with decentralization goals, and rejection would be rare.

UpdateConfigOfSubnet
UpdateConfigOfSubnet proposals change a subnet’s configuration parameters in the registry. These could include settings like max message sizes, replication factor, etc. It’s akin to tuning network parameters for performance or security on that subnet. Since consistency across nodes in a subnet is crucial, such changes need NNS approval. A conservative governance participant will assess if the new config maintains the subnet’s reliability and security. Typically, these proposals come from the core team when needed (for example, raising a message size limit to allow bigger canister upgrades). They have no bearing on ICP inflation or governance centralization, so the investor’s focus is technical merit. Baseline is to accept if the change is well-justified (with data or experience backing it). They would only deviate to reject if, say, the change seems rushed or has potential to destabilize the subnet (e.g., too large a bump in message size could risk DoS issues). Essentially, they trust expert judgment but verify that it’s not going to harm the network’s decentralization through unintended consequences (like a config that favors certain node hardware, indirectly centralizing to those who can meet it).


AddNodeToSubnet
AddNodeToSubnet proposals incorporate an idle (unassigned) node into an existing subnet. This expands the subnet’s membership, increasing its capacity or replacing a lost node. From the decentralization view, adding a node ideally improves resilience – but it depends on who operates the new node. A cautious ICP voter will approve if the new node operator is already part of the subnet’s trusted mix or further diversifies it (for example, adding a node from a new independent provider is a plus). If the node were from the same operator as many others in that subnet, the voter might worry about consolidation of control. They might still accept to maintain subnet function, but they would flag the centralization risk and push for future additions from other sources. No ICP tokens are created or destroyed here, but if many nodes from one entity are added over time, governance might become indirectly centralized (because that operator could collude or fail in unison). Thus, baseline accept but with an eye on the overall decentralization trend; if a pattern of one entity monopolizing additions emerges, one might start rejecting until balance is restored.

RemoveNodesFromSubnet
RemoveNodesFromSubnet proposals detach specified node machines from a subnet, making them unassigned (available for other subnets or maintenance). This could be due to node failure, operator termination, or to downsize a subnet. Removing a faulty or malicious node improves the subnet’s health and thus decentralization (by eliminating a bad actor). A careful investor will accept if the rationale is clear – for instance, the node is unresponsive or the operator is voluntarily withdrawing. They check that it’s not an arbitrary removal that could be used to target a specific operator unjustly (which would be a centralizing abuse if, say, a big stakeholder tries to kick out competitors’ nodes). Usually, however, these proposals are technical housekeeping. There’s no direct ICP monetary effect. The voter’s baseline is to accept to maintain network quality. They might consider rejecting only if the removal would drop the subnet below a safe size or if it appears politically motivated (e.g., removing nodes of an operator who voiced dissent – a far-fetched scenario, but a decentralization guardian stays alert to fairness).

ChangeSubnetMembership
ChangeSubnetMembership proposals perform an atomic swap of node membership in a subnet. They simultaneously remove certain nodes and add others in one proposal, which is useful for replacing nodes without downtime (one goes out as another comes in). This ensures continuity and avoids fractional states where a subnet might temporarily lose too many nodes. From our investor’s perspective, this is like combining the previous two types with additional safeguards. They support it if it’s used to refresh or rebalance a subnet’s composition for decentralization (e.g., swapping out nodes all from one data center with nodes from a more distributed set). It’s a complex change but ultimately neutral on ICP supply. A baseline voter accepts if the proposal clearly improves or maintains the decentralization and reliability of the subnet. They would check that the incoming nodes are ready and that the leaving nodes’ removal won’t cause issues. The only cause to reject would be if the swap reduces diversity (for example, swapping out two independent nodes and adding two nodes from the same provider – that would raise a red flag and likely prompt a no vote).


RecoverSubnet
RecoverSubnet proposals provide a new recovery CUP (Chain Unique Prefix) to revive a stalled subnet. If a subnet has halted (perhaps due to a catastrophic failure or too many nodes lost), this proposal gives the remaining nodes a point from which to restart (often using state from a backup or known good point). This is critical for resilience. A conservative voter will nearly always accept a well-formed recovery proposal because the alternative is leaving a subnet down, which is far worse for the network and users. The key is verifying that the recovery CUP is legitimate and comes from the subnet’s last consistent state (usually handled by DFINITY or trusted parties in collaboration with node providers). There’s no effect on ICP governance power or inflation – it’s purely operational. The only scenario for skepticism is if there were competing recovery proposals or controversy about the “right” state to recover (imagine two factions each claiming a different recovery point). In such a rare case, a cautious approach is needed – possibly delay or reject one proposal until consensus forms around a single recovery plan. But generally, this is a straightforward yes to restore decentralization (each subnet back up means the network is fully functional).


SetFirewallConfig
SetFirewallConfig proposals change the firewall rules configuration in the NNS registry for subnets, controlling which boundary nodes (ingress points) can communicate with the replicas of a subnet. In essence, it’s about network-level security: which endpoints are allowed. Tightening firewall rules can protect against DDoS or isolate malicious traffic, but if overdone, it could limit accessibility. An ICP governance hawk examines if the new config is security-driven or something that could be used for censorship. Generally, they accept proposals that come with clear technical justification (e.g., “Only allow boundary nodes X, Y, Z that are known-good, to mitigate ongoing attack”). This doesn’t print ICP or directly shift voting, but it does touch on openness of the network. If a firewall config ever proposed blocking a region’s access or non-DFINITY boundary nodes without cause, our investor might object due to the centralization/censorship concern. Baseline: approve necessary security changes; flag and reject if a proposal seems to cut out legitimate traffic or concentrate control of ingress in a worrisome way (like allowing only a single company’s boundary nodes to serve a subnet).

AddFirewallRules / RemoveFirewallRules / UpdateFirewallRules
These three proposal types manage individual firewall rules in the registry (adding new rules, removing old ones, or updating existing ones). They are fine-grained versions of SetFirewallConfig, often used to adjust specific IPs or ports. The perspective on them is similar: evaluate for genuine security improvement vs. potential misuse. A cautious voter typically accepts adds or updates that block malicious actors or open needed ports, and accepts removals that eliminate obsolete or overly harsh rules. Each rule change can affect how decentralized the network’s access is – e.g., if a rule blocks an entire ISP or country, that’s sensitive. Our ICP holder will demand that rules are as targeted as possible to avoid collateral damage. Since these proposals are usually technical and initiated by the nodes’ maintainer community or DFINITY, there’s trust but verify. They default to supporting them for network safety. A deviation to reject would be if a rule change appears to unjustifiably restrict access (thus concentrating the network’s availability to a subset of users) or if it was not communicated well (transparency is key to avoid paranoia about hidden centralization via networking).

SetAuthorizedSubnetworks
SetAuthorizedSubnetworks proposals tell the Cycles Minting Canister (CMC) which principals (users or canisters) are allowed to create canisters on certain subnets. This includes setting a default list for unspecified principals and special authorizations for privileged ones. In plainer terms, this controls who can deploy code to which subnet. Normally, most subnets are open to any canister creation if you have cycles, but some subnets (like system subnets) might be restricted. An ICP investor worried about centralization pays close attention here: if too restrictive, it could make the IC permissioned (a few entities control deployment on many subnets). If too open for critical subnets, security could suffer. The baseline is cautious accept if the change is, for example, opening up more subnets for general use (which decentralizes access to the network) or if it’s locking down only the NNS or other system subnets for good reason. If a proposal sought to heavily restrict many application subnets to only certain principals, that would smell of centralization and likely get a reject. Essentially, they want broad permission for the community by default and minimal use of whitelists. Adjustments that expand that default list or sensibly assign a new subnet type (like an experimental subnet limited to vetted testers) can be acceptable. They use the policy baseline “favor permissionless deployment” and deviate only when network health demands it.


UpdateSubnetType
UpdateSubnetType proposals modify the definitions of subnet types in the CMC. The IC supports different subnet types (e.g., “application”, “system”, “verified” subnets with certain features or hardware requirements). This proposal might add a new type or change parameters of an existing type (like replication factor, or whether it has a ledger canister). For governance, this is architectural. A prudent voter ensures this doesn’t create a “special class” of subnets that could be abused. If, say, a new subnet type is introduced that only one organization can run nodes for, that’s a possible centralization vector. The default approach is to support updates that enable new use cases (like a subnet type optimized for storage, etc.) as long as they remain open to multiple node providers. If the change formalizes something that was ad-hoc, it can improve clarity. There’s no ICP inflation issue here. They would reject if a subnet type seemed tailor-made to give a single party undue control or if it reduces the standards in a way that might compromise security (affecting everyone indirectly). But typically, these proposals are technical improvements.

ChangeSubnetTypeAssignment
ChangeSubnetTypeAssignment proposals reassign existing subnets to different subnet types or adjust which types a new subnet belongs to. For example, turning an “application” subnet into a “verified” subnet or vice versa by updating the registry. This can impact what canisters can be created there or special rules. From a decentralization standpoint, if a subnet is being reclassified, it should be done transparently and beneficially (maybe an experimental testnet subnet graduating to normal application status, etc.). The ICP voter will accept if the assignment change makes sense (perhaps aligning the subnet’s actual use with its type). They are careful that this isn’t used to quietly restrict a subnet – e.g., if a widely used application subnet was suddenly turned into a system subnet (which ordinary users can’t deploy to), that would raise concerns of gatekeeping. So the baseline is accept benign reassignments, but with oversight. If any assignment change reduces community access or appears to concentrate power (like moving a community-run subnet under a more centrally controlled type without strong justification), they would push back or reject.

UpdateSnsWasmSnsSubnetIds
UpdateSnsWasmSnsSubnetIds proposals update the list of subnet IDs designated to host SNS instances (decentralized autonomous organizations). SNS launch processes likely use specific “SNS subnets” to install the SNS canisters. This proposal type could add or remove which subnets are used for that purpose. An ICP investor with conservative values sees this as a way to control where new SNSes live. Ideally, multiple subnets (geographically and operator-diverse) are available for SNS deployments, so no single subnet or region is a bottleneck. Approving such proposals can decentralize SNS load. They’d accept if it increases the subnets (thus distributing SNS DAOs across more nodes) or if it rotates out a subnet that might be overloaded or unstable. They would be cautious if the change reduces the number of SNS subnets or picks subnets that are all managed by one entity – that could centralize SNS infrastructure. So a deviation to reject would occur if the new list seems less diverse or the reasoning isn’t sound. Generally, though, this is an innocuous update to keep the network flexible for hosting SNS canisters.


RerouteCanisterRanges
RerouteCanisterRanges proposals change the IC’s routing table in the registry, which maps ranges of canister IDs to subnets. If subnets are split or merged, or if certain ID ranges need to move to new subnets, this proposal executes that by updating where new canisters (or existing ones, in a migration scenario) will be assigned. It’s part of network reorganization, for example in scaling events. A careful governance participant supports this when it’s needed for a subnet split (to ensure new canister IDs go to the right place) or other rebalancing. It doesn’t create or destroy tokens, but it can affect users by moving canisters or altering which subnet they land on. They will accept if it is clearly part of a well-communicated plan (like splitting a large subnet into two for performance reasons). The main risk to watch: if done incorrectly, it could send canisters to a problematic subnet or create confusion. It’s not directly centralizing, but chaos in routing could undermine confidence. Baseline accept with due diligence; only if something appears technically flawed (e.g., overlapping ranges or missing a segment) would they possibly reject or ask for clarification.


PrepareCanisterMigration
PrepareCanisterMigration proposals insert or update records of planned canister movements between subnets in the registry. This is used when migrating canisters (e.g., during a subnet split or to offload a busy subnet). It sets up the list of canister IDs to be moved so that the system knows to treat them specially (like freezing them on source and expecting them on destination). Our prudent voter sees this as a necessary preliminary step to any large-scale migration. They will approve it if the migration plan has been explained (which set of canisters, why, to which subnet – often this comes with a forum post or proposal description). This type by itself doesn’t actually move anything; it’s a coordination step. There’s no impact on ICP supply or governance power. The potential worry could be if the list of canisters to migrate seemed arbitrary or if a canister owner objected – but since NNS can override canister placement, that’s usually resolved beforehand. Baseline is accept to enable smoother scaling and avoid one subnet being a choke point. Only if something is very off (like preparing migration of canisters that obviously shouldn’t move) would they consider rejecting.

CompleteCanisterMigration
CompleteCanisterMigration proposals finalize a canister migration by cleaning up the migration records after the move is done. This essentially signals that a migration is complete and removes the now-unneeded metadata. It’s housekeeping. The conservative voter will accept this, as it indicates the process is finished and the registry can be tidied. There is almost no scenario to reject – doing so would leave clutter or confusion in the registry. The only concern would be if someone prematurely calls “complete” before the migration is truly done, which could strand canisters. That would be an operational error; our voter would ensure (via the proposal text or technical team confirmation) that the migration succeeded. In absence of issues, this is a straightforward yes.


AddOrRemoveDataCenters
AddOrRemoveDataCenters proposals update the registry of authorized data center facilities. This could mean adding a new data center (with location info, capacity, etc.) where node hardware can be placed, or removing one that shut down or is disqualified. Each data center entry is part of ensuring node distribution across independent facilities. A decentralization-conscious ICP holder likes to see more data centers added across diverse geographies, as that spreads out risk. So they’ll accept additions that check out (proper identity, not too close to existing ones in ownership). Removing a data center usually happens if it’s no longer in use or violated rules; that too is accepted if justified (it might slightly reduce capacity, but possibly needed for compliance or security). These proposals don’t directly influence token counts or governance votes, but indirectly, a broader data center pool means a more decentralized node provider ecosystem. They’d be wary if a removal seems politically motivated or if not adding a promising new data center could indicate favoritism. Baseline: approve sound additions/removals to keep the registry current and decentralized; question or delay if something looks fishy (which is rare, as this is administrative).

AddOrRemoveNodeProvider
AddOrRemoveNodeProvider proposals assign or revoke a Node Provider identity. Node Providers are the entities (often individuals or organizations) that run node machines. Adding one means giving a new party the official status to host nodes (usually including a Node Provider ID and perhaps a reward account); removing might mean a provider exited or was disqualified. This is significant for decentralization: adding a new node provider expands the set of people controlling infrastructure, which is good as long as they are legitimate and independent. Our prudent investor will vote to accept new Node Providers who have been vetted (often KYC’d and approved by DFINITY’s operations) as it reduces concentration among existing providers. Removing a node provider might reduce diversity, but if that provider is no longer active or trusted, it’s necessary. They’d accept removal if, for example, the provider requested to resign or was found non-compliant. There is minimal direct ICP economy effect (except that node rewards will now also go to new providers). The baseline is pro-decentralization: welcome new operators, provided no red flags (like one entity creating multiple provider identities – that would be a trick to gain more rewards or influence, which they’d oppose). If any such suspicion arises, they might reject until clarified.


AssignNoid (Assign NOID)
AssignNoid proposals assign an identity (a “Node Operator ID”) to a new node operator along with their node allowance. Essentially, this onboards a new node operator who can then be allocated nodes to run, up to a certain number. This is closely related to the above Node Provider concept (in fact, Node Operator and Node Provider are sometimes used interchangeably, but Node Operator might refer to someone running nodes under a Node Provider entity). Regardless, approving this means trusting a new party to operate node hardware. A conservative voter strongly favors adding genuine, geographically and organizationally diverse node operators – it’s one of the primary defenses against centralization. They will accept if the applicant meets all requirements (often these proposals are put forward by the foundation after due diligence). More operators = more decentralization, in theory. They will also check that the allowance (how many nodes they can add) is reasonable and not excessive for a newcomer, to prevent any single operator from grabbing too large a slice of the network immediately. The baseline policy: approve new operators to broaden the network. Deviations (like rejecting) would only occur if, say, a known bad actor somehow made it to proposal or if adding that operator violates an agreed moratorium (perhaps if the network temporarily paused adding new nodes for technical reasons).

UpdateNodeOperatorConfig
UpdateNodeOperatorConfig proposals modify a node operator’s details in the registry, such as their remaining node allowance (the number of nodes they can still add). For instance, increasing an operator’s allowance if they’re approved to host more nodes, or decreasing it if some were allocated. It might also include other config like reward account changes. The investor’s worry here is if one operator’s allowance is increased dramatically, could that lead to centralization of nodes? They approach each change on its merits. If a reliable operator in an under-served region wants to add a few more nodes, that’s likely accepted because it improves network distribution. If an operator is already quite large, a proposal to let them host even more might give pause – ideally, node growth is spread across many operators. Still, if capacity is urgently needed and only that operator can supply, one might accept but keep an eye on decentralization metrics. This doesn’t change tokenomics directly, except that more nodes mean more rewards to that operator. Baseline accept if fair; potential reject if the change seems to give one operator outsized growth that isn’t counterbalanced by adding others – basically resisting any slippery slope to oligopoly among node operators.


RemoveNodeOperators
RemoveNodeOperators proposals remove a node operator (or multiple) from the registry. This could happen if an operator stops contributing or violates terms. Removing means they can no longer be assigned nodes (and any existing nodes under them might be reassigned or removed separately). A decentralization-minded voter is cautious because removing an operator reduces the pool of infrastructure providers. They will accept only if necessary – e.g., the operator shut down their data center or asked to be removed, or there were serious issues (maybe they didn’t maintain nodes, impacting network health). It’s essentially cleaning up dead weight or bad actors. There’s no joy in losing a participant, but sometimes it’s required. They will want assurance that any nodes run by that operator are taken over by others so that decentralization of running nodes doesn’t drop. If a removal looked unjustified, they’d reject – but typically such proposals are accompanied by explanations. So baseline yes if it’s a compliance or operational necessity, with the understanding this is not taken lightly.


RemoveNodes (Unassigned Nodes)
RemoveNodes proposals (in the NodeAdmin topic) remove unassigned nodes from the registry. These are machines that aren’t currently in any subnet – maybe they were added in anticipation but never used, or they went offline before assignment. Removing them is tidying up inventory so that only active, available nodes are listed. An ICP investor would see this as routine maintenance; it doesn’t hurt decentralization because unassigned nodes aren’t contributing anyway (and if they come back online, they could be re-added via another proposal). They’ll accept as it likely reflects reality (e.g., hardware was decommissioned). There’s no token or governance impact. It prevents clutter and possible confusion. They’d only question it if, for instance, a node that could have been used is being removed without clear reason – but even then, removal doesn’t preclude someone adding a node again later. So this is normally non-controversial.

UpdateSshReadonlyAccessForAllUnassignedNodes
UpdateSshReadonlyAccessForAllUnassignedNodes proposals update the SSH public keys allowed to log into all unassigned node machines in read-only mode. This is a security/maintenance function: authorized personnel (perhaps DFINITY or auditors) sometimes need SSH access to nodes that aren’t in use, to update software or check status. Granting or revoking such access across all idle nodes is done via this proposal. A security-conscious but decentralization-minded voter will accept this if it’s clear the keys being set are for trusted parties and the access is appropriately limited (read-only). It’s crucial for protecting nodes and prepping them for service. The risk angle: if someone maliciously got a key into this list, they could snoop on or prep nodes for bad use. So the voter ensures only intended keys (probably DFINITY’s ops team) are listed. This doesn’t relate to ICP token concerns directly. Baseline to approve since it usually strengthens operational security; a deviation to reject would happen if there’s any doubt about the legitimacy of the key change (which in practice is unlikely, as these proposals come from the team maintaining the network).


ApproveGenesisKYC
ApproveGenesisKYC proposals mark certain neuron principals (created at Genesis of the IC) as having passed KYC (Know Your Customer) checks. At Genesis (the initial launch), some neurons were created with GenesisKYC=false as a temporary restriction: those neurons could not spawn new neurons or be dissolved until their owners completed identity verification. This proposal type flips those flags to true for batches of principals who have now been verified. For an ICP investor, this is about fairness and unlocking rightful ownership. They will accept because it allows early contributors to finally access or use their ICP fully, which is good for decentralization (those users can now participate in governance and circulate tokens if they wish). There’s no dilution; it’s simply removing a restriction. Not approving would actually centralize by exclusion (keeping some genesis participants effectively out of governance). The baseline policy is to approve all valid KYC updates. One would only reject if something looked off – e.g., a principal that shouldn’t be KYC-approved slips in (but that would imply a procedural error by whoever curates the list). In summary, this is a yes – turning early neurons into normal neurons once compliance is done aligns with treating all investors equally.

ManageNeuron (Restricted Voting)
ManageNeuron proposals are special in that they allow a neuron’s designated manage-neuron followees to collectively execute a command on that neuron. Only the followers on the NeuronManagement topic for that neuron get to vote, not the whole NNS. The commands could include things like disbursing the neuron, merging maturity, etc., acting as if the neuron controller issued them. This is typically used in cases where a neuron is controlled by a community or multiple parties – for example, the Community Fund Neuron (Neurons’ Fund) is managed by such proposals so many people (the followees) have to agree to spend its resources. From a governance centralization standpoint, this is an interesting tool: it actually decentralizes control of a single neuron by spreading voting power among followers. A careful ICP holder accepts ManageNeuron proposals when they align with the neuron owner’s intent and benefit the community. For instance, if a Community Fund neuron wants to participate in an SNS sale, a ManageNeuron proposal might execute that participation – our voter would support it, since it’s the community’s will. There’s no direct ICP inflation (it’s using existing neuron funds), but misusing this could theoretically harm someone’s neuron. The voter’s baseline is trust but verify: these proposals are only valid if the neuron itself set things up to allow this (so it’s consensual). They would reject any ManageNeuron attempt that looks unauthorized or suspect – but by design, you cannot manage someone’s neuron unless they followed you on this topic. So practically, they follow the wishes of the neuron’s constituency, thus reinforcing collective governance rather than one-man control.

ExecuteNnsFunction (Historical)
ExecuteNnsFunction was a broad proposal type used historically as a catch-all for various governance actions identified by an nnsFunctionId code. Instead of distinct proposal names, older NNS proposals often were of this type with a payload indicating which internal function to run. Over time, these have been broken out into the specific types we’ve described above, but understanding them gives context to past proposals. Notable nnsFunctionId variants included:
CreateSubnet (ID 1) – Create a new subnet from unassigned nodes. (As discussed, adds capacity and decentralization.)

AddNodeToSubnet (ID 2) – Add a node to an existing subnet.

RemoveNodesFromSubnet (ID 3) – Remove nodes from a subnet.

BlessReplicaVersion (historical) – Approve a new IC protocol (replica) version for deployment (this is now done via ReviseElectedGuestOSVersions). It was crucial for upgrades, and investors accepted these from trusted releases.

RetireReplicaVersion (historical) – Remove an old replica version from the approved list (now part of ReviseElectedHostOSVersions). This ensured obsolete or insecure versions couldn’t be used, preventing potential rollback attacks.

UpdateSubnetConfig (ID 4) – Update configuration of a subnet (now UpdateConfigOfSubnet).

RecoverSubnet (ID 5) – Publish a recovery CUP to revive a subnet (now explicit RecoverSubnet type).

AddOrRemoveNodeProvider (ID 6) – Register a new node provider or remove one (still known as AddOrRemoveNodeProvider).

RewardNodeProviders (ID 7) – Distribute accumulated ICP rewards to node providers (often monthly). This paid node operators according to the Node Rewards Table, minting new ICP for them
. Investors treated these carefully: they were usually routine and expected (thus accepted to keep nodes funded), but they watched the amounts since large payouts contribute to token dilution.

ManageNetworkEconomics (ID 8) – Update network economic parameters (now the NetworkEconomics proposal type). Changes to things like reject fee, minimum stake, etc., as covered above. Generally contentious if they affect inflation or participation barriers.

ApproveGenesisKYC (ID 9) – Mark genesis neurons as KYC-approved (as now).

UpdateICPXdrConversionRate (ID 10) – Update the ICP/XDR conversion rate used by the cycles minting canister for creating cycles (this was done via frequent proposals historically, now automated by the Exchange Rate Canister)
medium.com. These proposals, often submitted by DFINITY’s oracles, were critical to maintain a correct conversion rate but had to be rate-limited to avoid spam. A conservative voter expects them to pass (they’re usually automated and vital for the IC economy), but they remain watchful that the feed is accurate to prevent any entity from manipulating the rate, which could indirectly affect cycle costs.

BitcoinSetConfig (ID 39) – Configure the Bitcoin integration canister (now the named proposal type).

OpenSnsTokenSwap (historical) – Initiate an SNS decentralization swap (token sale) for a project, including the Community Fund participation. It was used to launch SNS tokens with NNS oversight. However, due to complexity and a discovered bug with multiple concurrent proposals, it has been deprecated in favor of a simplified one-proposal process
internetcomputer.org. Conservative voters initially approached these with caution, ensuring the sale parameters were fair and wouldn’t siphon too much maturity from the Neurons’ Fund (to avoid diluting voting rewards).

SetSnsTokenSwapOpenTimeWindow (historical) – Set or adjust the time window during which an SNS token swap can start (often paired with OpenSnsTokenSwap). This too was removed when the SNS launch process was streamlined
dashboard.internetcomputer.org
.
InsertSnsWasmUpgradePathEntries (ID 48) – Add SNS upgrade path entries (now a named type).
ClearProvisionalWhitelist (ID 49) – Remove all entries in the provisional whitelist of the cycles minting canister. This whitelist, used only in the IC’s early days, allowed certain principals to create canisters freely (bypassing the normal ICP->cycles conversion) for bootstrapping purposes. Clearing it signals the network is mature and no special cases are needed. A conservative governance approach strongly favors clearing once appropriate, as continuing a privileged whitelist would be an ongoing centralization/red-tape factor. Indeed, when such proposals came up, they were seen as milestones in decentralization and typically accepted wholeheartedly.
Each of these functions, when proposed, was evaluated on its own merits – much like their modern counterparts. The cautious ICP investor’s stance across all ExecuteNnsFunction variants was to default to the NNS’s established policy (often accept if it benefits network health/security and doesn’t unduly concentrate power or inflate supply). They would flag exceptions: for example, they expected to accept routine upgrades and expansions, but would consider rejecting an economics change that seemed to favor a narrow group, or would demand justification for large token swaps or reward payouts. Over time, the granularity of proposal types increased (as we have detailed above), which helps voters apply their conservative criteria more specifically to each category of decision.

Adjustable Governance Parameters (Network Economics)
(These parameters are modified via NetworkEconomics proposals. The conservative baseline policy is to leave these unchanged unless a change clearly improves decentralization or network function without introducing significant downsides. Each entry notes when a justified deviation from the status quo might be considered.)


Reject Cost
Reject cost is the amount of ICP that the proposer of a rejected proposal must pay as a penalty. This acts as a spam filter: if someone submits frivolous or malicious proposals and they get voted down, the network burns a bit of their ICP. A higher reject cost discourages spam but also could discourage legitimate proposals from small holders (who fear losing ICP if their proposal fails). A lower cost makes proposing more accessible but risks an influx of low-quality proposals. The current conservative approach is to have a non-zero cost that’s noticeable but not prohibitive. A cautious ICP investor wants this balanced to prevent spam (which could be used by a bad actor to disrupt governance or push centralizing narratives) without centralizing proposal power to only the wealthy. They typically favor keeping or adjusting the reject fee to the minimum level needed to stop obvious spam. If spam attacks increase, they might support raising this fee (with reluctance) to protect the governance process. Conversely, if the fee is too high and silences community initiatives, they’d consider lowering it. Baseline: keep as is; deviate to raise only if governance is under siege by spam (a justified hardening), deviate to lower if participation drops because only big players dare propose.


Minimum Neuron Stake
Minimum neuron stake is the least amount of ICP required to create a neuron (and also to perform certain operations like increasing dissolve delay). This threshold ensures that neurons have “skin in the game” and filters out dust accounts from clogging the system. However, if set too high, it excludes many holders from governance, effectively centralizing voting power to large ICP owners. If set too low, someone could split a modest holding into a large number of tiny neurons to game followee voting or rewards. The cautious investor’s viewpoint is that the minimum stake should stay low enough to allow broad participation (decentralization of governance) but high enough to prevent exploitation or an explosion of neurons that could be sybil attacks. They generally resist increases to this parameter since raising the bar would concentrate governance among wealthier holders, which goes against the ideal of a decentralized DAO. They would only accept a higher minimum if there were clear evidence of abuse via tiny neurons. Conversely, they are open to lowering it slightly if it’s proven that honest smaller holders are being unfairly shut out and if other anti-spam measures (like reject cost and neuron fees) can compensate for more neurons. The baseline is to maintain the current minimum stake; any change must carefully consider the trade-off between inclusivity and security.


Neuron Management Fee
The neuron management fee is a (typically small) ICP fee charged for submitting certain types of neuron proposals/commands that have only local neuron impact. An example might be if a neuron wanted to split itself or perform some manage-neuron functions via proposal. The fee exists to prevent abuse of the system with a flood of management actions (like repeatedly spawning and merging neurons to grind rewards or clogging the governance canister with trivial tasks). For the average staker, these fees are minor, but they add up if someone tries to automate many calls. From a governance perspective, this parameter doesn’t directly centralize power, but if set incorrectly, it could tilt the playing field. If too high, ordinary users might avoid legitimate management operations (like splitting a neuron for organizational reasons), giving an edge to those who can afford it – a subtle form of centralization by wealth. If too low, a bad actor could spam manage-neuron proposals and perhaps distract the NNS. The cautious investor likely supports keeping this fee just high enough to deter spam. They would reject any proposal to eliminate or drastically reduce it unless accompanied by alternative spam protections. They’d also be wary of raising it too much; that would be like over-pricing a basic feature, which is against the ethos of accessible governance. Baseline: minimal necessary fee to prevent abuse, and any adjustments should be minor and justified by clear changes in network usage patterns.


Minimum ICP/XDR Rate
The minimum ICP/XDR rate is a safety floor for the conversion rate of ICP to XDR (a basket currency) used in the NNS (for example, by the cycles minting canister). This prevents accidental or manipulated scenarios where ICP is valued near zero in conversion calculations. In practice, it ensures that if external feeds failed or went crazy, the NNS wouldn’t, say, give away huge amounts of cycles for 1 ICP due to a momentary glitch valuing ICP at fractions of a cent. A conservative-minded token holder likes having this backstop, but also knows it should rarely if ever kick in. They want the minimum rate low enough that it only triggers in extreme emergencies (so normal market fluctuations don’t hit it), but not so low that if it’s ever used, it floods the system with cheap cycles (which could indirectly increase effective ICP supply in circulation as cycles or let someone exploit it). Adjusting this parameter might be necessary if ICP’s market dynamics change drastically. The cautious voter’s baseline is not to touch this unless needed. They’d approve changing it only if, for example, ICP’s value had fallen a lot over time and the existing floor was now above market price (which could freeze conversions – so the floor might need lowering), or conversely if they wanted to set a new higher floor after an exploit. Neither scenario is taken lightly. There’s no centralization risk per se, but there is economic risk. Thus, any change must be justified by new data, and they default to keeping the current safe value.

Dissolve Delay of Spawned Neurons
This parameter defines the initial dissolve delay for new neurons spawned from the maturity of an existing neuron. “Spawning” a neuron is when you take accumulated voting rewards (maturity) and create a new neuron with it. The dissolve delay of that spawned neuron can be set by policy – perhaps to ensure it’s not zero (forcing the rewards to be locked for a while, aligning incentives). A conservative participant sees this as aligning long-term incentives: if spawn delay is, say, 1 year by default, it means reward-derived ICP can’t be immediately cashed out – reducing instant sell pressure and dilution effect on the market. If set too high, it might discourage using the spawn feature (people might prefer merging maturity or just not participating fully). If too low, spawned neurons could be immediately dissolved and sold, increasing short-term ICP float (dilution) and potentially letting large voters churn out ICP quickly. The cautious stance is to set a moderate required delay (maybe on the order of months) to strike a balance. Historically, this might have been adjusted to fine-tune reward dynamics. Our voter would approve a change if the evidence showed that current behavior (spawn-and-sell) was harming token value or if, conversely, too many rewards stayed locked unnecessarily. They primarily want to avoid sudden surges of ICP selling (which dilute existing holders’ value). Baseline likely keeps some months-long dissolve on spawned neurons; they’d only shorten it if it’s proving too much of a barrier and driving people not to spawn at all (which then accrues huge maturity, another risk), or lengthen it if rewards are being dumped en masse.

Maximum Node Provider Rewards
This sets an upper limit on the total ICP that can be distributed in a single node provider rewards event. Essentially, even if the Node Rewards Table says a higher amount is due, the NNS will not pay above this cap in one go. This parameter directly relates to ICP inflation, because node rewards are newly minted tokens given to node providers for their work. A conservative ICP holder is quite sensitive about this: too high a cap could allow large infusions of ICP into circulation, diluting other holders. Too low a cap, however, might underpay node providers, risking network stability if nodes become unprofitable (which in turn could centralize by driving out smaller providers). So it’s a delicate balance. The cautious approach is to size the cap such that it accommodates normal operations and modest growth in nodes, but not unbounded payouts. Typically, they’d set it around the expected monthly or quarterly reward sum plus some margin. If node count or ICP price changes, this might need tweaking. The voter will generally oppose increases to this cap unless absolutely justified (like if ICP price doubled and the fiat value of the cap became too low to cover costs, an increase might be needed to keep node ops viable). They would more readily consider lowering it if inflation is running hotter than expected or if participation is dropping (signs that rewards might be overly generous). However, any lowering must coincide with either reducing node costs or other adjustments, lest we alienate node providers. The baseline is to keep inflation predictable – meaning keep this cap at a level consistent with the original tokenomics (no surprise jumps). Deviations: accept an increase only to preserve the network (not to simply enrich providers), accept a decrease if it doesn’t endanger operations and helps curb dilution.

Transaction Fee
The transaction fee is the fixed ICP fee for each ledger transaction on the IC. This affects users sending ICP and can also affect canister ledger operations. A higher fee can sink small amounts of ICP permanently (which is deflationary, a tiny counter to dilution) and prevent spam transactions; a lower fee makes ICP more convenient for everyday use but might allow micro-spam and means less ICP is burned over time. The fee also indirectly signals how much we want to charge for usage of the ICP ledger. A conservative ICP investor weighs this carefully: on one hand, they don’t want the fee so high that it discourages legitimate usage or drives users to off-chain solutions (that would reduce the ICP ecosystem’s utility, possibly centralizing transactions off-network). On the other hand, some fee is healthy for security and to slightly offset inflation via burn. Historically the fee has been very low (like 0.0001 ICP or similar). Our voter is likely fine with the status quo and would be skeptical of any change. They’d reject a significant fee hike because it could harm adoption and be seen as gouging users (and a greedy NNS is not in the long-term interest of decentralization or token holders). They’d also reject eliminating the fee entirely, because zero-fee could open floodgates to spam and stress the ledger. The only justified change might be adjusting for ICP price fluctuations: if ICP’s value changed 10x, maybe you tweak the fee to keep its USD value roughly constant for usability. Overall, expect conservatism – minimal adjustments, maintaining a nominal fee that’s low enough for anyone to transact but non-zero.

Maximum Proposals Kept per Topic
This parameter limits how many proposals (that have reached a final state) are retained in the system per topic. Once the cap is exceeded, the oldest proposals in that topic (that are already decided) may be purged to save storage space. From a governance transparency perspective, having a history of proposals is valuable for audit and learning. However, the NNS cannot grow without bound, so a cap is needed. If this number is too low, valuable historical data is lost quickly, and new participants can’t see what happened in the past – that could concentrate knowledge in those who were around (a subtle centralization of context). If too high, the governance canister might bloat, making it harder to run and possibly centralizing in another way (only very resource-rich nodes could handle it, etc.). The current default is likely sufficient to hold at least months or a couple years of history in each topic. A prudent NNS voter will accept an increase in this limit if storage costs go down or if the community deems more history is worth keeping for transparency, as long as it doesn’t impair performance. They will accept a decrease only reluctantly, if there’s a technical need (e.g., the governance canister is nearing capacity). In either case, they weigh community access to past info heavily – archiving off-chain might be a mitigation if we have to lower it. Baseline: keep it as is (which is already a compromise between infinite history and none). They definitely wouldn’t let it drop to a point where, say, only a week of proposals is kept, as that would harm accountability and favor insiders who remember past events.


Neurons’ Fund (Community Fund) Parameters
These parameters govern the behavior of the Neurons’ Fund (formerly Community Fund), which is a collective pool of neuron maturity that can invest in SNS launches. The ones listed include:
max_theoretical_neurons_fund_participation_amount_xdr: an upper bound (in XDR value) of how much the fund could commit to a single SNS swap.
neurons_fund_matched_funding_curve_coefficients: defines the matching curve for fund participation (how the fund’s contribution scales with direct contributions).
minimum_icp_xdr_rate and maximum_icp_xdr_rate for the fund: bounds on the conversion rate used when calculating contributions, protecting the fund against ICP price extremes during swaps.
From a conservative investor’s viewpoint, these parameters are about safeguarding the Community Fund from either over-allocating to a single project or being mis-valued. Essentially, they prevent dilution of neuron rewards and ensure fairness in SNS launches:
The max participation ensures the fund doesn’t dump an overly large amount of ICP (via maturity conversion) into one project, which could be seen as dilutive or risky for those contributors.
The matching curve coefficient sets how generously the fund matches regular investors in SNS; a steep curve could deplete the fund quickly or favor certain sizes of contribution. Ideally, it should encourage broad participation without the fund shouldering too much.
The ICP/XDR rate bounds ensure that if ICP’s price swings, the fund doesn’t accidentally contribute far too much or too little in real terms.
The conservative stance is to keep these parameters tuned so the fund is helpful but not reckless. An ICP investor in the NNS wants the Neurons’ Fund to succeed (it can boost ICP ecosystem projects) but also not to inadvertently harm overall token economics by committing too much or by creating an arbitrage. They would approve changes to these parameters if, say, early SNS launches revealed that the existing values were suboptimal (perhaps the matching was too generous and drained the fund, or not generous enough to matter). Any change should ensure the fund remains a communal good, not captured by any entity. There’s little risk of governance centralization here directly, but mismanagement could reduce the fund (which is a collectively owned resource). So they scrutinize proposals to alter these values, aiming to preserve the fund’s health and fairness. Baseline is to leave them unless there’s evidence-backed reason (for example, if no SNS is hitting the current max, maybe lower it to protect funds; or if ICP volatility requires updating the conversion bounds).


ClearProvisionalWhitelist
The ClearProvisionalWhitelist proposal (yes/no flag) removes all entries from the provisional whitelist of principals allowed to create canisters with cycles without going through ICP conversion. This mechanism was a bootstrap tool for early IC development and testing. Keeping a provisional whitelist longer than necessary is inherently centralizing – it means only whitelisted principals (often DFINITY internal accounts) can do certain actions freely. Clearing it signifies full transition to a permissionless network where nobody has special privileges in creating canisters. A deeply decentralization-oriented ICP holder is strongly in favor of this once the network has matured past the need. In fact, by the time such a proposal comes (it did, historically), they will almost certainly accept. It’s one of those rare governance moves that purely removes a centralization vestige. The only reason to have delayed it was if the network still critically needed that backdoor for stability or onboarding key services. By now, any justification to keep a whitelist is likely gone. So the baseline policy is to accept clearing the whitelist (which the user likely did). A deviation (like rejecting the clear) would only have been justifiable very early on if some crucial deployment pipeline still relied on it – but at this stage, not clearing it would be a glaring deviation from decentralization. Thus, a conservative voter would mark this as a necessary step and happily adopt it, burning the last “training wheels” and ensuring all canister creation is governed by the same rules for everyone.